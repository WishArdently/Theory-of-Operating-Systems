## 内存管理

### 一、基础知识

#### 1、内存保护

使用寄存器保存基址和段长。

#### 2、地址绑定

指令和数据（符号名、变量名）绑定到内存

（1）编译时绑定

（2）加载时绑定

（3）运行时绑定

#### 3、地址变换和重定位

（1）地址变换——逻辑地址（读写操作）$\rightarrow$物理地址（MMU完成）

（2）地址重定位——逻辑地址（程序）$\rightarrow$物理地址（装载器或动态链接器）

#### 4、静态地址重定位

在虚拟空间程序执行之前由装配程序完成地址映射过程。

仅对首地址进行操作——偏移映射

$物理地址 = 逻辑地址 + offset$

优点：容易实现、无需硬件支持

缺点：程序经过重定位之后便无法移动，不能重新分配内存，不利于内存有效利用

​			必须连续分配，难以做到程序和数据共享。

#### 5、动态地址重定位

在程序执行过程中，CPU访问内存之前，将程序或数据地址转化为内存地址（物理地址）。

对不同程序设立不同的基址寄存器，仍然使用偏移映射规则。

优点：可以对内存进行非连续分配、可用于实现虚拟内存技术、有利于程序共享。

缺点：需要附加硬件支持、实现存储管理的软件算法复杂。

#### 6、静态链接

$hello.o\rightarrow hello$

由装配连接器程序将各程序段链接在一起。（iostream库直接与主程序段合并）

花费时间、空间

#### 7、动态链接

只将主程序段调入内存，在运行时调入所需要的程序段（iostream库中的puts函数在运行时才调用内存）

<img src="C:\Users\16958\AppData\Roaming\Typora\typora-user-images\image-20231220142940682.png" alt="image-20231220142940682" style="zoom:60%;" />

### 二、连续内存分配

#### 1、单一连续分配

内存中只驻留一道作业，连续存放。

主存分为系统区（内存低端）、用户区（内存高端），存放相应的程序。

单道批处理系统、静态分配（结束才释放内存）。

优点：方法简单，易于实现

缺点：仅适用于单道程序

#### 2、固定分区分配

静态划分分区，划分完毕则分组长度和分区数量不再改变。

使用**分区说明表**说明区号、长度、起始地址、状态（Allocated or Unallocated）

优点：管理简单，系统开销小
缺点：不灵活，对大程序不友好，利用率低，**内部碎片大**

#### 3、动态分区分配

使用分区说明表的同时，使用**可用分区表**和**可用分区自由链**。

（1）可用分区表

优点：管理过程简单

缺点：表的大小难以确定；可用表需要占用内存。

（2）可用分区自由链

优点：不必占用额外的内存区（将链接信息放入区内）
缺点：查找困难

两种方法均会产生**内碎片**。

#### 4、动态分区分配算法

（1）最先适应（First-fit）

顺序查找大小合适的分区。

优点：算法简单、开销小

缺点：无

（2）最佳适应（Best-fit）

优先使用能够适应的最小分区。

优点：能满足大进程需求

缺点：会产生很多**外碎片**、内存利用率低、开销大（排序）

（3）最坏适应（Worst-fit）

优先使用能够适应的最大分区。

优点：减少外碎片

缺点：不利于大进程、开销大（排序）

（4）邻近适应（Next Fit）

将空闲分区表构建成一个循环链表，每次从上次结束的位置开始顺序查找合适的分区。

优点：算法开销小

缺点：使高地址的大分区被用完，不利于大进程。

#### 5、回收与拼接

回收内存空间时，更新可用分区表或可用分区自由链，尽可能拼接表项。

<img src="C:\Users\16958\AppData\Roaming\Typora\typora-user-images\image-20231220152501819.png" alt="image-20231220152501819" style="zoom:67%;" />

#### 6、紧缩技术

通过移动内存内容、合并表项来解决外碎片问题。（仅动态重定位可用）

### 三、分页管理

#### 1、概念

**页框**：page结构体

将物理内存分为固定大小的块，将逻辑内存分为同样大小的块，利用页表进行逻辑地址到物理地址的映射。

一维地址空间。

会产生**内碎片**。

#### 2、页表的结构

页号隐式表达（下标），页面对应物理块号。

存在**页表基址寄存器**，记录页表的首地址（类似数组名称）。

存在**页表长度寄存器**，记录页表的长度（类似数组长度）。

#### 3、逻辑地址的结构

页号+页内偏移。

页号位数由**页表**大小决定，页内偏移由**页面**大小决定。

**地址翻译**：通过页号查页表得知对应物理块号，页内偏移指向物理块内的某一个位置。

每次数据/指令的访问都要访问两次内存（页表、页内偏移）。

#### 4、TLB

又叫相联存储器、转换表缓冲区、快表。

获取数据/指令时先查快表，快表命中则返回物理页帧号，未命中则查阅页表。

#### 5、内存保护

在页表中设置一个有效位，有效时表示该页在该进程的逻辑地址空间中，无效则表示该页不合法。  

#### 6、多级页表

（1）单级页表存在的问题

页表必须连续存放，当页表很大时需要占用很多的页来存储页表。

不需要让整个页表常驻内存，程序可能暂时用不到某些页。

（2）二级页表：一级页表查得的物理页帧中存放二级页表，再查二级页表即可得到数据存放的真正物理页帧。

​		  页表长度 = 页表大小 / 页表项大小

​		  逻辑地址 = 一级页号 + 二级页号 + 块内偏移

​		  两级页号的位数等于页表长度位数。

（3）无快表的条件下，访存次数 = 页表级数 + 1

#### 7、哈希页表

（1）多级页表存在的问题

级数过多的情况下访存速度慢。

（2）实现：通过哈希函数映射到相应的块。

#### 8、倒置页表

（1）按物理内存构建页表，每个页帧在倒置页表中有一个条目

（2）页表的大小取决于物理内存的大小，整个系统只有一张页表（减少存储页表所使用的存储空间）。

### 四、分段管理

#### 1、基本思想

​	把程序按过程分成若干段，每个段对应主存中的一个**二维线性虚拟空间**，以段为单位分配内存，然后通过**地址映射机构（段表）**把段式虚拟地址转化为实际的内存物理地址。

#### 2、段表

（1）逻辑地址：段号+段内偏移

（2）段表：每个表项包含两项——段基址和段界限

（3）**段表基址寄存器（STBR）**指向内存中的段表地址

​		  **段表长度寄存器（STLR）**指向进程中的段数

#### 3、内存保护

（1）实现

在段表的表项内设立有效位，表示执行权限

（2）分配算法

动态分区式分配算法。

#### 4、段的共享

（1）内存中只保存一个副本，供多用户使用。

（2）共享段的指令和数据**不能修改**。

（3）共享段仅当所有使用它的进程退出时才能回收。

#### 5、优缺点

（1）优点：方便用户编程、便于实现共享和保护、便于动态链接、便于应对数组增长。

（2）缺点：对硬件要求更大、碎片难以管理、允许段的动态增长实现开销大、段长受内存可用区大小限制

### 五、段页式管理

#### 1、段式管理和页式管理的优缺点

（1）页式管理

​			优点：分配与回收简单，内存利用率高，外部碎片少

​			缺点：不易于共享，需静态连接

（2）段式管理

​			优点：易于共享，可动态连接，符合程序逻辑结构，段大小可动态扩充

​			缺点：分配与回收困难，有外部碎片，碎片整理开销大；每个段的长度受内存可用去大小的限制

#### 2、虚拟地址的构成

每个进程拥有一个自己的二维地址空间。

（1）进程的具有独立逻辑功能的程序和数据仍被划分成段，并有各自的段号s

（2）每一段中再分为不同的页，并有自己的页号

（3）虚拟空间的最小单位是**页**而不是段，内存可用区被分为若干个大小相等的页面，且每段所拥有的程序和数据在内存中可以分开存放，分段的大小也就不再受内存可用区的限制了。

#### 3、动态地址变换过程

访存步骤：查段表$\rightarrow$查页表$\rightarrow$访问物理单元

通过快速联想寄存器来提高地址转换速度。

#### 4、优缺点

（1）优点

同时具有分页管理和分段管理的优点。

（2）缺点

实现复杂、开销大、需要的硬件支持和占用内存增大。

### 六、虚拟内存

#### 1、基础

（1）引入原因

足够**大**。——编程时无需考虑物理内存实际大小。

足够**快**。

（2）基本思想——将用户逻辑内存和物理内存分开

将物理内存分块（页/段）、按需调入内存、特定中断（**page fault**）、物理内存不够则通过交换腾出内存。

（3）特性

进程执行时只有部分内容需要调入内存

逻辑地址空间远大于物理地址空间

允许多进程共享地址空间

允许更有效地创建进程。

（4）先决条件

非连续内存管理、动态地址重定位、交换技术、**局部性原理**

需要有相当容量的辅存和一定容量的主存，需要设置地址变换机构。

#### 2、请求式分页管理

也叫动态页式管理。

（1）页表机制

页号（隐式）、页面号、状态位（valid/invalid）、外存始址、改变位（执行写指令时更新，M位）、引用位（R位）。

（2）缺页中断

当要访问的页面不在内存时，产生缺页中断。

此时缺页进程阻塞，完成调页后将其唤醒。

若内存中存在空闲页，将空闲页调入内存，修改页表相关信息。

若内存中不存在空闲页，则通过页面置换算法进行页面交换。

（3）地址变换机构

操作系统负责调入需要的页面、释放暂时不用的页面。

通过页表查找相应的物理页，判断其是否在内存中，若不在内存中则执行缺页中断。

（4）页面置换算法

**最佳置换（OPT）：**

选择淘汰以后将永不使用或者在最长时间内不使用的页面。

优点：缺页率最低。

缺点：无法实现。

**先进先出（FIFO）：**

每次选择最早进入内存的页面进行淘汰。

优点：实现简单。

缺点：会产生Belady异常。（可用物理块数增多时缺页次数不减反增的现象）

**二次机会算法（优化FIFO，Clock， NRU）：**

需要设置一个引用位，将页面通过链接指针连接成循环队列。

访问某页成功$\rightarrow$该页引用位置1

淘汰页面：扫描所有页面，如果引用位是0，淘汰；如果是1，置0，暂不换出。

​					若第一轮扫描失败，则再扫第二轮，找到第一个引用位是0的页。

**最近最久未使用（LRU）:**

选择最近最久未使用的页面进行淘汰，需要设置一个标记上次访问时间的计数器。

计数器更新规则：

访问成功$\rightarrow$计数器清0其余加一

访问失败但有空闲页$\rightarrow$将页调入内存，计数器清0，原先比该页计数器小的页计数器加一

访问失败且无空闲页$\rightarrow$选择计数器最大的页面进行淘汰，新换入的页计数器清0，其余页计数器加一

优点：性能好。

缺点：实现困难、开销大。

**NFU（近似LRU）：**

为每个页面设置一个计数器，记录该页面的使用次数，每使用一次计数器加一。

选择计数器最小的页面淘汰。

过于重视历史。

**老化算法（近似LRU）：**

为每个页面设置计数器（初值为0）。

访问成功$\rightarrow$最高位加一

时钟中断$\rightarrow$计数器右移一位

缺页中断$\rightarrow$淘汰计数器值最小的页

<img src="C:\Users\16958\AppData\Roaming\Typora\typora-user-images\image-20231221210542409.png" alt="image-20231221210542409" style="zoom:80%;" />

**非最近使用（NRU）**

同时应用页表项中的标志位（R）和修改位（M）

访问成功：R位设置为1，OS每隔一个周期将R位清0.

页面被修改：M位设置为1

页面淘汰：（R和M会出现四种情况）淘汰00。

MR = 01，改为00，放到队尾

MR = 10，改为00，放到队尾

MR = 11，改为10，放到队尾

淘汰优先级：00 > 01 > 10 > 11

（5）请求式分页管理的优点：更少的I/O，更少的内存空间、更快的响应、更多的用户

#### 3、物理帧管理

（1）概念

**目标**：减少换入换出的时间

**空闲帧缓冲池**：无需等待牺牲帧写出。直接从缓冲池找到一块空闲内存。牺牲帧换出后，再放入缓冲池。

**已修改页列表**：调页设备空闲时写出。未修改页面不换出。

**空闲帧池**：换出的帧在重用前进空闲帧池。

**驻留集**：请求分页存储管理中给进程分配的物理块的总大小。

（2）分配策略

**固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行时驻留集大小不变。分为比例分配和平均分配。

**优先级分配**：根据进程优先级进行分配，发生缺页时，可以从低优先级进程中进行置换。



**局部置换**：发生缺页时只能选进程自己的物理块进行置换。

缺点：不能使用其他进程不常用的内存空间

**全局置换**：发生缺页时可选其他进程或者操作系统保留的空闲物理块进行置换。

缺点：不能控制进程的缺页率



（3）抖动

频繁的页面换入换出行为。

产生原因：进程驻留集小于进程频繁访问的页面数量。

结果：CPU利用率低、操作系统认为需要增加多线程并发度、系统中新增一个进程——利用率进一步下降



（4）工作集模型

**驻留集**：请求分页存储管理中给进程分配的物理块的总大小。（不能小于工作集大小）

**工作集**：在某段时间内，进程实际访问页面的集合。

$\Delta \equiv\  $工作集窗口（固定数量的指令）

工作集 = $unique(\Delta)$

$\Delta$太小无法包括整个局部区；太大会包括更多局部区；无穷大则会包含整个程序。

<img src="C:\Users\16958\AppData\Roaming\Typora\typora-user-images\image-20231223113352838.png" alt="image-20231223113352838" style="zoom:60%;" />

#### 4、内核内存分配

（1）用户态进程$\rightarrow$空闲页链表中获取

​		  内核内存$\rightarrow$空闲池中获取

（2）Buddy系统——产生碎片（大内存分配）

从物理上连续大小的固定的段上分配。

分配二的整数幂大小的段。

<img src="C:\Users\16958\AppData\Roaming\Typora\typora-user-images\image-20231223114434957.png" alt="image-20231223114434957" style="zoom:60%;" />

（3）Slab分配——不产生碎片（小内存分配）

按内核数据结构确定slab不同分块大小，每个内核数据结构一个cache

每个内核对象对应一个高速缓存，每个高速缓存对应n个slab，每个slab对应n个连续物理页。

<img src="C:\Users\16958\AppData\Roaming\Typora\typora-user-images\image-20231223121145241.png" alt="image-20231223121145241" style="zoom:60%;" />







